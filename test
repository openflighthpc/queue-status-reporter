diff --git a/queue_status.rb b/queue_status.rb
index a893643..7eafd7b 100644
--- a/queue_status.rb
+++ b/queue_status.rb
@@ -40,22 +40,23 @@ def running_threshold
   (ENV['RUN_THRESHOLD'] || 10080).to_i
 end
 
-def formatted_threshold(value)
-  result = ""
-  if value >= 1440
-    result << "#{value.divmod(1440)[0]}day"
-    result << "s" if value >= 2880
-    result << " "
-    value = value.divmod(1440)[1]
-  end
-  if value >= 60
-    result << "#{value.divmod(60)[0]}hr"
-    result << "s" if value >= 120
-    result << " "
-    value = value.divmod(60)[1]
-  end
-  result << "#{value}m" if value > 0
-  result.strip
+# Convert an integer holding a number of seconds
+# to a human readable format
+def humanise_seconds(secs)
+  [[60, :s], [60, :m], [24, :hr], [Float::INFINITY, :day]].map do |count, name|
+    if secs > 0
+      secs, n = secs.divmod(count)
+      n = n.to_i
+      "".tap do |s|
+        unless n == 0
+          s << "#{n}#{name}"
+          if n > 1 && (name == :hr || name == :day)
+            s << 's'
+          end
+        end
+      end
+    end
+  end.compact.reverse.join(' ')
 end
 
 # Construct a hash to store command line arguments.
@@ -178,7 +179,7 @@ partitions.each_with_index do |(partition, details), index|
   long_running.sort_by! { |job| job[1] }
   partition_msg << "#{details[:running].length} job(s) running on partition #{partition}\n"
   if details[:running].any?
-    partition_msg << "#{long_running.length} job(s) have been running for more than #{formatted_threshold(running_threshold)}"
+    partition_msg << "#{long_running.length} job(s) have been running for more than #{humanise_seconds(running_threshold)}"
     if long_running.any? && user_args.key?('show_ids')
       partition_msg << ": #{long_running.map {|job| job[1] }.join(", ") }"
     end
@@ -240,7 +241,7 @@ partitions.each_with_index do |(partition, details), index|
     if cant_determine_wait.length > 0 && cant_determine_wait.length == details[:pending].length
       partition_msg << "Insufficient data to estimate job start times\n"
     elsif details[:pending].any?
-      partition_msg << "#{waiting.length} job(s) estimated not to start within #{formatted_threshold(wait_threshold)} after submission"
+      partition_msg << "#{waiting.length} job(s) estimated not to start within #{humanise_seconds(wait_threshold)} after submission"
       if waiting.any? && user_args.key?('show_ids')
         partition_msg << ": #{waiting.map {|job| job[1] }.join(", ") }"
       end
@@ -304,7 +305,7 @@ msg = ["*#{Time.now.strftime("%F %T")}*\n",
        (": #{down.join(", ")}" if down.any?),
        "\n\n",
        "#{total_running} total job(s) running\n",
-       ("#{total_long_running.length} total job(s) have been running for more than #{formatted_threshold(running_threshold)}" if total_running > 0),
+       ("#{total_long_running.length} total job(s) have been running for more than #{humanise_seconds(running_threshold)}" if total_running > 0),
        (": #{total_long_running.map {|job| job[1] }.join(", ") }" if total_long_running.any? && show_ids),
        ("\n" if total_running > 0),
        "#{total_pending} total job(s) pending\n",
@@ -312,7 +313,7 @@ msg = ["*#{Time.now.strftime("%F %T")}*\n",
        (": #{jobs_no_resources.map {|job| job[1] }.join(", ") }"  if jobs_no_resources.any? && show_ids),
        "\n",
        ("Insufficient data to estimate job start times" if no_start_data),
-       ("#{total_long_waiting.length} total job(s) estimated not to start within #{formatted_threshold(wait_threshold)} after submission" if !no_start_data),
+       ("#{total_long_waiting.length} total job(s) estimated not to start within #{humanise_seconds(wait_threshold)} after submission" if !no_start_data),
        (": #{total_long_waiting.map {|job| job[1] }.join(", ") }"  if total_long_waiting.any? && !no_start_data && show_ids),
        ("\nInsufficient data to estimate job start times for #{total_cant_determine_wait.length} job(s)" if total_cant_determine_wait.any? && !no_start_data),
        (": #{total_cant_determine_wait.map {|job| job[1] }.join(", ") }" if total_cant_determine_wait.any? && !no_start_data && show_ids),
